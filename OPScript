local Fluent = loadstring(game:HttpGet("https://github.com/dawid-scripts/Fluent/releases/latest/download/main.lua"))()

local CurrentVersion = "Infinite Mining Incremental v1"

local Window = Fluent:CreateWindow({
    Title = CurrentVersion,
    SubTitle = "by ngw12345",
    TabWidth = 160,
    Size = UDim2.fromOffset(580, 460),
    Acrylic = true, -- The blur may be detectable, setting this to false disables blur entirely
    Theme = "Darker",
    MinimizeKey = Enum.KeyCode.LeftControl -- Used when theres no MinimizeKeybind
})

-- Local Var List
local rootPart = game.Workspace.ngw12345.HumanoidRootPart

-- Fluent provides Lucide Icons, they are optional
local Tabs = {
    Teleports = Window:AddTab({ Title = "Teleports", Icon = "" }),
    AutoFarm = Window:AddTab({ Title = "AutoFarm", Icon = "" }),
    Settings = Window:AddTab({ Title = "Settings", Icon = "settings" })
}

local SaveManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/SaveManager.lua"))()
local InterfaceManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/InterfaceManager.lua"))()

SaveManager:SetLibrary(Fluent)
InterfaceManager:SetLibrary(Fluent)

InterfaceManager:BuildInterfaceSection(Tabs.Settings)
SaveManager:BuildConfigSection(Tabs.Settings)

local isAutoFarm = false

-- Utility: Find the closest ore roughly straight below the player within verticalRange
local function getClosestOreBelow(verticalRange, toleranceRadius)
    local rootPos = rootPart.Position
    local closestOre = nil
    local closestDistance = math.huge

    for _, ore in pairs(workspace.Ores:GetChildren()) do
        if ore:IsA("Part") then
            local orePos = ore.Position
            local verticalDistance = rootPos.Y - orePos.Y
            if verticalDistance > 0 and verticalDistance <= verticalRange then
                -- Check horizontal distance from rootPart.XZ to ore.XZ
                local horizontalDist = (Vector3.new(rootPos.X, 0, rootPos.Z) - Vector3.new(orePos.X, 0, orePos.Z)).Magnitude

                -- Only consider ores roughly straight below within a small horizontal radius (toleranceRadius)
                if horizontalDist <= toleranceRadius and verticalDistance < closestDistance then
                    closestDistance = verticalDistance
                    closestOre = ore
                end
            end
        end
    end

    return closestOre
end

-- Add Toggle to Tabs.AutoFarm
local FarmToggle = Tabs.AutoFarm:AddToggle("AutoFarmToggle", {
    Title = "AutoFarm (Straight Down)",
    Description = "Automatically mines ores straight down below you",
    Default = false,
    Callback = function(state)
        isAutoFarm = state
        print(isAutoFarm and "AutoFarm Enabled" or "AutoFarm Disabled")
    end
})

-- Background mining loop
task.spawn(function()
    while true do
        if isAutoFarm then
            local verticalRange = 30     -- How far down to check
            local toleranceRadius = 4    -- How close horizontally it must be to count as 'straight down'

            local ore = getClosestOreBelow(verticalRange, toleranceRadius)
            if ore then
                local args = { ore }
                game:GetService("ReplicatedStorage").Events.MineOre:FireServer(unpack(args))
                task.wait(0.05) -- slight delay between mining
            else
                task.wait(0.1) -- no ore found, wait a bit longer
            end
        else
            task.wait(0.15)
        end
    end
end)

local selectedOre = 1
local isAutoMining = false
local miningThread = nil

-- Dropdown for ore selection
local Dropdown = Tabs.AutoFarm:AddDropdown("OreDropdown", {
    Title = "Select Ore",
    Description = "Choose the ore to mine",
    Values = {"Chest", "10", "101101", "11", "12", "14", "Abyssal Stone", "Alagamite", "Alternatus", "Ambrosia", "Ammolite", "Aqueduelis Blue", "Aqueduelis Red", "Augelite", "Blue", "Chronoverde", "Coal", "Constellatium", "Copper", "Core", "Cordierite", "Crimsonstone", "Crookesite", "Celsian", "Datolite", "Darkmatter", "Darkstone", "Decayium", "Devilline", "Diamond", "Dragonglass", "Duskium", "Eclipse", "Ekanite", "Evorium", "Firecrystal", "Fracturium", "Galactium", "Galactic Shard", "Garnet", "Glitchite", "Glitchite Reborn", "Green", "Indicolite", "Indigo", "Inferno", "Iron", "Jasper", "Lightning Crystal", "Lithium", "Lucentium", "Lunalyx", "Malachite", "Marble", "Masslock", "Mineralite", "Mintite", "Miroite", "Morganite", "Nautilus", "Nautilus Evolved", "Niedermayrite", "Obamite", "Orange", "Platinum", "Plutonium", "Radiant Quartz", "Rainbonite", "Rainbonium", "Realgar", "REDACTED", "Red", "Redlinite", "Redrum", "Rozenite", "Royalty", "Ruby", "Serenity", "Shadowite", "Solar Blossom", "Spongebob", "Stone", "Stellarite", "Superium", "Taaffeite", "Timeite", "Voltiblue", "Violet", "Void Crystals", "Wadsleyite", "Warped Coal", "Yellow", "Yumium"},
    Multi = false,
    Default = 1,
    Callback = function(value)
        selectedOre = value
    end
})

-- Toggle for AutoFarm
local Toggle = Tabs.AutoFarm:AddToggle("SelectedOreAutoFarmToggle", 
{
    Title = "Selected Ore AutoFarm", 
    Description = "Teleports to each ore and mines it",
    Default = false,
    Keybind = nil,
    Callback = function(state)
        isAutoMining = state

        -- Stop old thread if it exists
        if miningThread then
            miningThread = nil
        end

        -- Start new thread
        if state then
            miningThread = task.spawn(function()
                while isAutoMining do
                    if selectedOre then
                        local oresFolder = game.Workspace:FindFirstChild("Ores")
                        if oresFolder then
                            -- Gather and shuffle matching ores
                            local matchingOres = {}
                            for _, ore in pairs(oresFolder:GetChildren()) do
                                if ore.Name == selectedOre and ore:IsA("BasePart") then
                                    table.insert(matchingOres, ore)
                                end
                            end
                            for i = #matchingOres, 2, -1 do
                                local j = math.random(1, i)
                                matchingOres[i], matchingOres[j] = matchingOres[j], matchingOres[i]
                            end

                            -- Loop through shuffled ores
                            for _, ore in ipairs(matchingOres) do
                                if not isAutoMining then break end
                                if ore and ore.Parent then
                                    -- Teleport above the ore
                                    ore.CFrame = rootPart.CFrame - Vector3.new(0, 3, 0)
                                    task.wait(0.2)

                                    -- Fire the mining remote
                                    game:GetService("ReplicatedStorage").Events.MineOre:FireServer(ore)

                                    -- Wait until the ore is removed
                                    local startTime = tick()
                                    while ore.Parent and (tick() - startTime < 3) do
                                        task.wait(0.1)
                                    end

                                    task.wait(0.2) -- small buffer
                                end
                            end
                        end
                    end
                    task.wait(1) -- delay before scanning again
                end
            end)
        end
    end
})
